================================================================================
CONTEXTO COMPLETO: PROBLEMA DE CAMBIO DE CONTRASE√ëA EN SUPABASE
================================================================================

PROBLEMA:
---------
Despu√©s de cambiar la contrase√±a usando OTP personalizado, el usuario NO puede 
hacer login con la nueva contrase√±a. Recibe error "Invalid login credentials".

Flujo:
1. ‚úÖ Usuario solicita cambio ‚Üí OTP se env√≠a por email (funciona)
2. ‚úÖ Usuario ingresa OTP correcto ‚Üí OTP se verifica (funciona)
3. ‚úÖ Usuario ingresa nueva contrase√±a ‚Üí Sistema confirma cambio (funciona)
4. ‚ùå Usuario intenta login con nueva contrase√±a ‚Üí ERROR "credenciales inv√°lidas"

Stack:
- Backend: Supabase (PostgreSQL + Auth)
- Frontend: Flutter (Dart)
- Edge Functions: Deno/TypeScript
- Email: SendGrid (v√≠a servidor PHP con IP est√°tica)

Sistema de OTP Personalizado:
- NO usamos el flujo est√°ndar de Supabase (resetPasswordForEmail)
- Usamos tabla personalizada: password_reset_otps
- Edge Function send-otp: Genera OTP de 6 d√≠gitos
- Edge Function verify-otp: Verifica OTP y actualiza contrase√±a

M√©todos intentados (TODOS FALLARON):
1. admin.updateUserById({ password: newPassword }) - Reporta √©xito pero no funciona
2. API REST directa PUT /auth/v1/admin/users/{id} - Mismo problema
3. Esperar propagaci√≥n (2s, 5s, 10s, 20s) - No ayuda
4. Sistema de reintentos - No ayuda
5. Verificaci√≥n de login despu√©s de actualizar - Confirma que NO funciona

================================================================================
ARCHIVO 1: supabase/functions/verify-otp/index.ts
================================================================================

// deno-lint-ignore-file no-explicit-any
import 'jsr:@supabase/functions-js/edge-runtime.d.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

Deno.serve(async (req) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json',
  }

  if (req.method === 'OPTIONS') {
    return new Response(null, { status: 204, headers: corsHeaders })
  }
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: corsHeaders,
    })
  }

  const { email, otp_code, new_password } = await req.json().catch(() => ({}))
  if (!email || !otp_code || !new_password) {
    return new Response(JSON.stringify({ error: 'email, otp_code y new_password requeridos' }), {
      status: 400,
      headers: corsHeaders,
    })
  }

  const SUPABASE_URL = Deno.env.get('SB_URL')!
  const SERVICE_ROLE_KEY = Deno.env.get('SERVICE_ROLE_KEY')!
  if (!SUPABASE_URL || !SERVICE_ROLE_KEY) {
    return new Response(JSON.stringify({ error: 'Faltan variables de entorno' }), {
      status: 500,
      headers: corsHeaders,
    })
  }

  const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY)

  // Buscar OTP v√°lido
  const now = new Date().toISOString()
  const { data: rows, error: selErr } = await supabase
    .from('password_reset_otps')
    .select('*')
    .eq('email', email)
    .eq('used', false)
    .gte('expires_at', now)
    .order('created_at', { ascending: false })
    .limit(1)

  if (selErr || !rows || rows.length === 0) {
    return new Response(JSON.stringify({ error: 'OTP inv√°lido o expirado' }), {
      status: 400,
      headers: corsHeaders,
    })
  }

  const otpRow = rows[0]
  if (String(otpRow.otp_code) !== String(otp_code)) {
    return new Response(JSON.stringify({ error: 'OTP inv√°lido' }), { status: 400, headers: corsHeaders })
  }

  // Obtener usuario por email
  const { data: users, error: usersErr } = await supabase.auth.admin.listUsers({
    page: 1,
    perPage: 1,
    email
  } as any)
  if (usersErr || !users?.users?.length) {
    return new Response(JSON.stringify({ error: 'Usuario no encontrado' }), {
      status: 400,
      headers: corsHeaders,
    })
  }

  const user = users.users[0]
  
  // SOLUCI√ìN EST√ÅNDAR: Generar un token de recuperaci√≥n est√°ndar de Supabase
  console.log('üîë Generando token de recuperaci√≥n est√°ndar de Supabase...')
  let recoveryToken: string | null = null
  
  try {
    const { data: linkData, error: linkError } = await supabase.auth.admin.generateLink({
      type: 'recovery',
      email: email,
    } as any)
    
    if (!linkError && linkData?.properties?.action_link) {
      const actionLink = linkData.properties.action_link
      const tokenMatch = actionLink.match(/token=([^&]+)/)
      if (tokenMatch) {
        recoveryToken = tokenMatch[1]
        console.log('‚úÖ Token de recuperaci√≥n generado exitosamente')
      }
    }
  } catch (linkErr) {
    console.warn('‚ö†Ô∏è Error generando token de recuperaci√≥n:', linkErr)
  }

  console.log(`üîê Actualizando contrase√±a para usuario: ${user.id} (${user.email})`)
  
  let passwordUpdated = false
  let lastError: any = null
  
  // Intentar m√∫ltiples veces con diferentes m√©todos
  for (let attempt = 1; attempt <= 3; attempt++) {
    console.log(`üîÑ Intento ${attempt}/3 de actualizar contrase√±a...`)
    
    try {
      const updateResult = await supabase.auth.admin.updateUserById(user.id, {
        password: new_password,
      } as any)
      
      if (updateResult.error) {
        console.error(`‚ùå Error en intento ${attempt}:`, updateResult.error.message)
        lastError = updateResult.error
        
        if (attempt === 3) {
          console.log('üîÑ √öltimo intento: Usando API REST directa...')
          const authUrl = `${SUPABASE_URL.replace('/rest/v1', '')}/auth/v1/admin/users/${user.id}`
          const updateResponse = await fetch(authUrl, {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${SERVICE_ROLE_KEY}`,
              'apikey': SERVICE_ROLE_KEY,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              password: new_password,
            }),
          })
          
          if (updateResponse.ok) {
            console.log('‚úÖ Contrase√±a actualizada usando API REST directa')
            passwordUpdated = true
            break
          } else {
            const errorData = await updateResponse.json()
            console.error('‚ùå Error en API REST:', errorData)
            lastError = errorData
          }
        }
      } else {
        console.log(`‚úÖ Contrase√±a actualizada exitosamente (intento ${attempt})`)
        passwordUpdated = true
        break
      }
    } catch (err: any) {
      console.error(`‚ùå Excepci√≥n en intento ${attempt}:`, err.message)
      lastError = err
    }
    
    if (attempt < 3) {
      await new Promise(resolve => setTimeout(resolve, 1000))
    }
  }
  
  if (!passwordUpdated) {
    console.error('‚ùå No se pudo actualizar la contrase√±a despu√©s de 3 intentos')
    return new Response(JSON.stringify({ 
      error: 'No se pudo actualizar la contrase√±a',
      details: lastError?.message || 'Error despu√©s de m√∫ltiples intentos'
    }), { status: 500, headers: corsHeaders })
  }
  
  console.log('‚úÖ Contrase√±a actualizada exitosamente')
  
  // Esperar propagaci√≥n
  console.log('‚è≥ Esperando propagaci√≥n del cambio (5 segundos)...')
  await new Promise(resolve => setTimeout(resolve, 5000))
  
  // Verificar usuario
  const { data: verifyUser, error: verifyErr } = await supabase.auth.admin.getUserById(user.id)
  if (verifyErr) {
    console.warn('‚ö†Ô∏è No se pudo verificar el usuario despu√©s de actualizar:', verifyErr)
  } else {
    console.log(`‚úÖ Usuario verificado despu√©s de actualizar: ${verifyUser.user?.email}`)
  }
  
  // Test de login para verificar que la contrase√±a funciona
  console.log('üß™ Verificando que la contrase√±a es v√°lida (diagn√≥stico)...')
  let passwordWorks = false
  
  try {
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY')
    if (SUPABASE_ANON_KEY) {
      const testClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      await new Promise(resolve => setTimeout(resolve, 3000))
      
      const { data: testLogin, error: testErr } = await testClient.auth.signInWithPassword({
        email: email,
        password: new_password,
      })
      
      if (testErr) {
        console.warn('‚ö†Ô∏è ADVERTENCIA: La verificaci√≥n de contrase√±a fall√≥')
        console.warn(`   Error: ${testErr.message}`)
        console.warn(`   Status: ${testErr.status || 'N/A'}`)
        passwordWorks = false
      } else {
        console.log('‚úÖ Verificaci√≥n exitosa: La contrase√±a funciona correctamente')
        passwordWorks = true
        await testClient.auth.signOut()
      }
    }
  } catch (testError: any) {
    console.warn('‚ö†Ô∏è Error al verificar la contrase√±a:', testError)
    passwordWorks = false
  }
  
  if (!passwordWorks) {
    console.warn('‚ö†Ô∏è La verificaci√≥n fall√≥, pero la contrase√±a deber√≠a funcionar despu√©s de unos segundos')
  }

  // Marcar OTP como usado
  const { error: updOtpErr } = await supabase
    .from('password_reset_otps')
    .update({ used: true })
    .eq('id', otpRow.id)

  if (updOtpErr) {
    console.error('No se pudo marcar OTP como usado', updOtpErr)
  }

  // Retornar token de recuperaci√≥n si se gener√≥
  if (recoveryToken) {
    console.log('‚úÖ Retornando token de recuperaci√≥n para m√©todo est√°ndar')
    return new Response(JSON.stringify({ 
      ok: true, 
      recovery_token: recoveryToken,
      use_standard_method: true 
    }), { status: 200, headers: corsHeaders })
  }

  return new Response(JSON.stringify({ ok: true }), { status: 200, headers: corsHeaders })
})

================================================================================
ARCHIVO 2: lib/services/auth_service_simple.dart (m√©todo verifyOTPAndResetPassword)
================================================================================

  // Verificar OTP y actualizar contrase√±a usando el M√âTODO EST√ÅNDAR de Supabase
  Future<void> verifyOTPAndResetPassword({
    required String email,
    required String token,
    required String newPassword,
  }) async {
    try {
      print('üîê Verificando OTP usando m√©todo est√°ndar de Supabase...');
      print('   Email: $email');
      print('   Token OTP: ${token.substring(0, 3)}...');
      print('   Nueva contrase√±a: ${newPassword.length} caracteres');
      
      // PASO 1: Verificar OTP personalizado y obtener token de recuperaci√≥n est√°ndar
      final res = await _supabase.functions.invoke('verify-otp', body: {
        'email': email,
        'otp_code': token,
        'new_password': newPassword,
      });
      
      dynamic data = res.data;
      if (data is String) {
        try {
          data = jsonDecode(data);
        } catch (_) {}
      }
      
      if (res.status != 200 || (data is Map && data['ok'] != true)) {
        final err = (data is Map ? (data['error'] ?? 'Verificaci√≥n OTP fallida') : 'Verificaci√≥n OTP fallida');
        throw Exception(err);
      }
      
      // PASO 2: Si el servidor gener√≥ un token de recuperaci√≥n est√°ndar, usarlo
      if (data is Map && data['recovery_token'] != null && data['use_standard_method'] == true) {
        print('‚úÖ Token de recuperaci√≥n est√°ndar recibido, usando m√©todo est√°ndar...');
        final recoveryToken = data['recovery_token'] as String;
        
        try {
          final session = await _supabase.auth.exchangeCodeForSession(recoveryToken);
          
          if (session.session == null) {
            throw Exception('Token de recuperaci√≥n inv√°lido');
          }
          
          print('‚úÖ Token de recuperaci√≥n verificado correctamente');
          
          // Actualizar contrase√±a usando el m√©todo est√°ndar (esto SIEMPRE funciona)
          final updateResponse = await _supabase.auth.updateUser(
            UserAttributes(password: newPassword),
          );
          
          if (updateResponse.user == null) {
            throw Exception('No se pudo actualizar la contrase√±a');
          }
          
          print('‚úÖ Contrase√±a actualizada exitosamente usando m√©todo est√°ndar');
          
          // Cerrar sesi√≥n temporal
          await _supabase.auth.signOut();
          print('‚úÖ Sesi√≥n temporal cerrada');
          
          print('‚úÖ Proceso completado - La contrase√±a est√° lista para usar');
          return;
        } catch (recoveryError) {
          print('‚ö†Ô∏è Error usando m√©todo est√°ndar, la contrase√±a ya fue actualizada por el servidor: $recoveryError');
        }
      }
      
      // Si no hay token de recuperaci√≥n, la contrase√±a ya fue actualizada por el servidor
      print('‚úÖ Contrase√±a actualizada por el servidor');
      await _supabase.auth.signOut();
      
    } catch (e, stackTrace) {
      print('‚ùå Error en verificaci√≥n OTP o actualizaci√≥n de contrase√±a: $e');
      print('üìö Stack trace: $stackTrace');
      rethrow;
    }
  }

================================================================================
ARCHIVO 3: database/custom_otp_password_reset.sql
================================================================================

-- Tabla para OTP de recuperaci√≥n de contrase√±a
create table if not exists public.password_reset_otps (
  id uuid primary key default gen_random_uuid(),
  email text not null,
  otp_code text not null,
  expires_at timestamptz not null,
  used boolean not null default false,
  created_at timestamptz not null default now()
);

-- √çndices √∫tiles
create index if not exists idx_password_reset_otps_email on public.password_reset_otps (email);
create index if not exists idx_password_reset_otps_expires_at on public.password_reset_otps (expires_at);
create index if not exists idx_password_reset_otps_used on public.password_reset_otps (used);

-- Pol√≠tica de seguridad (RLS): s√≥lo funciones/servidor deben acceder a esta tabla
alter table public.password_reset_otps enable row level security;
drop policy if exists select_none_password_reset_otps on public.password_reset_otps;
create policy select_none_password_reset_otps on public.password_reset_otps
  for select using (false);
drop policy if exists modify_none_password_reset_otps on public.password_reset_otps;
create policy modify_none_password_reset_otps on public.password_reset_otps
  for all using (false);

================================================================================
ARCHIVO 4: lib/services/auth_service_simple.dart (m√©todo signIn - para referencia)
================================================================================

  Future<AuthResponse> signIn({
    required String email,
    required String password,
    bool saveForBiometric = false,
  }) async {
    try {
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user != null) {
        await _loadUserFromSession(response.session!);
        
        if (saveForBiometric) {
          await saveBiometricCredentials(email: email, password: password);
        }
        final prefs = await SharedPreferences.getInstance();
        await prefs.remove('force_login');
      }

      try {
        await SubscriptionService().checkSubscriptionStatus();
        print('‚úÖ Estado de suscripci√≥n verificado despu√©s de login');
      } catch (e) {
        print('‚ö†Ô∏è Error verificando suscripci√≥n despu√©s de login: $e');
      }

      return response;
    } catch (e) {
      print('‚ùå Error en login: $e');
      print('‚ùå Tipo de error: ${e.runtimeType}');
      print('‚ùå Stack trace: ${StackTrace.current}');
      rethrow;
    }
  }

================================================================================
LOGS DE SUPABASE (verify-otp)
================================================================================

Los logs muestran:
‚úÖ Contrase√±a actualizada exitosamente (intento X)
‚úÖ Usuario verificado despu√©s de actualizar
‚ö†Ô∏è ADVERTENCIA: La verificaci√≥n de contrase√±a fall√≥
   Error: Invalid login credentials
   Status: 400

Esto confirma que:
- La contrase√±a se "actualiza" seg√∫n Supabase
- Pero NO funciona para hacer login

================================================================================
PREGUNTA PARA CHATGPT
================================================================================

¬øC√≥mo implementar correctamente el cambio de contrase√±a en Supabase cuando se 
usa un sistema de OTP personalizado?

Contexto:
- Usamos tabla personalizada password_reset_otps (no podemos cambiar a resetPasswordForEmail)
- El OTP se verifica correctamente
- admin.updateUserById({ password: newPassword }) reporta √©xito pero la contrase√±a NO funciona para login
- Hemos esperado m√°s de 20 segundos - no es problema de propagaci√≥n

Preguntas espec√≠ficas:
1. ¬øHay alg√∫n problema conocido con admin.updateUserById() para actualizar contrase√±as?
2. ¬øHay alg√∫n paso adicional necesario despu√©s de actualizar la contrase√±a?
3. ¬øNecesitamos invalidar sesiones o hacer algo m√°s?
4. ¬øCu√°l es la forma CORRECTA de actualizar contrase√±as usando Admin API en Supabase?
5. ¬øHay alguna diferencia entre actualizar contrase√±a para usuarios existentes vs nuevos?
6. ¬øEl m√©todo admin.updateUserById() realmente actualiza el hash de la contrase√±a correctamente?

Informaci√≥n adicional:
- Versi√≥n de Supabase: Cloud (no self-hosted)
- Versi√≥n de SDK: supabase_flutter (√∫ltima)
- M√©todo de login: signInWithPassword(email, password)
- Error espec√≠fico: "Invalid login credentials" (c√≥digo 400)

================================================================================
FIN DEL DOCUMENTO
================================================================================


